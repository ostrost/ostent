/* eslint indent:0 */
/* esline-env node */
/* global Buffer:false, __dirname:false, process:false, require:false */

var child             = require('child_process'),
    ExtractTextPlugin = require('extract-text-webpack-plugin'),
    React             = require('react'),
    ReactDOMServer    = require('react-dom/server'),
    gulp              = require('gulp'),
    babel             = require('gulp-babel'),
    header            = require('gulp-header'),
    pug               = require('gulp-pug'),
    rename            = require('gulp-rename'),
    spawn             = require('gulp-spawn'),
    gutil             = require('gulp-util'),
    _                 = require('lodash'),
    path              = require('path'),
    purify            = require('purifycss-webpack-plugin'),
    through           = require('through2'),
    webpack           = require('webpack'),
    util              = require('util'),
    argv              = require('yargs').argv;
//  reload            = require('gulp-livereload');

gulp.task('pug', function() {
  gulp.src(argv.input)
    .pipe(pug({locals: _.merge(argv, {format: util.format}), pretty: true}))
    .pipe('JSX' in argv ?
          spawn({cmd: 'ostent-templatepp',
                 args: '--definesfrom - --template'.split(' ').concat(argv.template)}) :
          gutil.noop())
    .pipe('JSX' in argv ?
          header('// Generated by ostent-templatepp. This comment is essential.\n') :
          gutil.noop())
    .pipe(rename(argv.output))
    .pipe(gulp.dest('.'));
});

function ssr(options) {
  return through.obj(function(file, enc, cb) {
    if (file.isStream()) {
      return cb(new gutil.PluginError('ssr', 'Streaming not supported'));
    }
    try {
      var mod = eval(file.contents.toString());
      var str = ReactDOMServer.renderToString(
        React.createElement(mod, options));
      file.contents = new Buffer('[[define "page"]]'+ str +'[[end]]');
      return cb(null, file);
    } catch (err) {
      this.emit('error', new gutil.PluginError('ssr', err, {fileName: file.path}));
    }
    cb();
  });
}

var babelOptions = {
  plugins: [
    'babel-plugin-transform-react-constant-elements',
    'babel-plugin-transform-react-inline-elements',
    'transform-react-jsx',
    'transform-react-pug'],
  presets: ['react', 'es2015']
};

gulp.task('ssr', function() {
  gulp.src(argv.input)
    .pipe(babel(babelOptions))
    .pipe(ssr({ssr: true}))
    .pipe(rename(argv.output))
    .pipe(gulp.dest('.'));
});

var node_modules = path.join(__dirname, './node_modules');
var wpconf = {
  bail: true,
  resolve: {
    root: [node_modules],
    //? extensions: ['', '.js', '.jsx', '.css', '.scss'],
  },
  module: {
    loaders: [
      {test: /\.css$/,  loader: ExtractTextPlugin.extract('style-loader', 'css-loader')},
      {test: /\.scss$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader?minimize&core=false!sass-loader')},
      {
        test: /\.jsx?$/,
        loader: 'babel',
        exclude: /node_modules/,
        query: babelOptions
      }
    ],
    postLoaders: [{loader: 'transform?envify'}]
  },
  sassLoader: {includePaths: [node_modules+'/foundation-sites/scss/']},
  plugins: [
    new ExtractTextPlugin('index.css', {allChunks: true}),
    new purify({paths: [
      'share/templates/*.html',
      'share/js/*.js*'
    ]}) // */
  ]
};

gulp.task('webpack', [], function(callback) {
  var wparg = wpconf;
  wparg = _.merge(wparg, {entry: argv.input});
  wparg = _.merge(wparg, {output: {}});
  wparg.output.filename = path.basename(argv.output);
  wparg.output.path     = path.join(__dirname, path.dirname(argv.output));
  if (argv.output.match(/\.min\.js($|\?)/i) !== null) {
    wparg.plugins.push(new webpack.optimize.UglifyJsPlugin({mangle: true, sourceMap: false}));
    process.env.NODE_ENV = 'production';
  } else if (argv.output.match(/\.js($|\?)/i) !== null) {
    wparg.plugins.push(new webpack.BannerPlugin('// Generated by webpack. This comment is essential.', {raw: true}));
    // The comment makes linguist detect generated code: https://github.com/github/linguist/blob/master/lib/linguist/generated.rb#L148
  }
  webpack(wparg).run(function(err, stats) {
    if (err !== null) {
      throw new gutil.PluginError('webpack', err);
    }
    var statsString = stats.toString({chunks: false});
    if (stats.hasErrors() === true) {
      throw new gutil.PluginError('webpack', statsString);
    }
    gutil.log('[webpack]', statsString);
    callback();
  });
});

// The watch part:

var server = null, makep = {_cmd: 'make'};

function dup(std, proc) {
  return proc[std].on('data', function(d) { process[std].write(d.toString()); });
  /*
  return proc[std].on('data', function(d) {
    var lines = d.toString().split('\n');
    for (var i in lines) {
      util.log(lines[i]); // util is gulp-util
    }
  }); // */
}

gulp.task('which gmake', function(cb) {
  var proc = child.spawn('which', ['gmake']);
  proc.stdout.on('end', cb);
  proc.stdout.on('data', function() { makep._cmd = 'gmake'; });
  dup('stderr', proc);
});

gulp.task('gmake dev', ['which gmake'], function() {
  var proc = child.spawn(makep._cmd, '-C . dev'.split(' '));
  dup('stdout', proc);
  dup('stderr', proc);
});

gulp.task('gmake print', ['which gmake'], function(cb) {
  var proc = child.spawn(makep._cmd, 'print-package print-devpackagefiles'.split(' '));
  proc.stdout.on('end', cb);
  proc.stdout.on('data', function(d) {
    var lines = d.toString().split('\n');
    for (var i in lines) {
      var words = d.toString().split('=');
      makep[words[0]] = words[1].replace(/\n$/, '').split(' ');
    }
  });
  dup('stderr', proc);
});

gulp.task('server build', function(cb) {
  var goget = 'CGO_ENABLED=1 go get -v -race'; // Race detector requires cgo compiler.
  var proc = child.spawn('env', (goget+' '+makep.package[0]).split(' '));
  proc.stdout.on('end', cb);
  dup('stdout', proc);
  dup('stderr', proc);
});

gulp.task('server run', ['server build'], function() {
  var run = function() {
    server = child.spawn(makep.package[0].replace(/.*\//, ''), process.argv.slice(3));
    dup('stdout', server);
    dup('stderr', server);
    // server.stdout.once('data', function() { reload.reload('/'); });
  };
  if (server !== null) {
    server.kill();
    setTimeout(run, 1000);
  } else {
    run();
  }
});

gulp.task('server watch', function() {
  gulp.watch(makep.devpackagefiles.map(function(x) { return __dirname + '/' + x; }),
             ['server run']);
});

gulp.task('watch', ['gmake print'], function() {
  // reload.listen();
  gulp.start(['server watch', 'server run']);
  gulp.watch([
    __dirname+'/share/js/*',
    __dirname+'/share/style/*',
    __dirname+'/share/templatesorigin/*'
  ], ['gmake dev']);
});
